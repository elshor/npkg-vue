// @ts-nocheck
/*
 *   Copyright (c) 2021 DSAS Holdings LTD.
 *   All rights reserved.
 */

import Vue from "vue";
import { isDevMode } from "./utils";

function addEntries(target,source){
	source = source || {};
	Object.entries(source).forEach(([key,value])=>target.push({key,value}));
}

export function fnComponent(spec,npath){
	if(!spec){
		return undefined;
	}
	const input = getRenderInputFromScript(spec,npath);
	return function(h,thisObject=null,overrideProps={},overrideData={}){
		input.data.key = overrideData.key || input.data.key;
		input.data.slot = overrideData.slot || input.data.slot;
		input.data.ref = overrideData.ref || input.data.ref;
		input.data.refinFor = overrideData.refInFor || input.data.refInFor;
		addEntries(input.data.props,overrideProps);
		addEntries(input.data.props,overrideData.props);
		addEntries(input.data.on,overrideData.on);
		addEntries(input.data.attrs,overrideData.attrs);
		return renderInput(input,thisObject||this,h);
	}
}

/**
 * Given an input object of comp, data (props, style etc.) and children, generate a vnode
 * @param {Object} input 
 * @param {*} thisObject 
 * @param {Function} h  render function
 * @returns VNode
 */
function renderInput(input,thisObject,h,parentInput){
	if(!input){
		return undefined;
	}
	//check if display condition exists and true
	if(input.condition){
		const b = input.condition.call(thisObject);
		if(!b){
			return undefined;
		}
	}

	//calculate data
	const data = calcData(
		input.data,
		thisObject,
		parentInput? parentInput.data : null,
		input.entry,
		input.spec
	);

	//register spec id
	data._sid = input.spec.$id;

	//render children
	const children = input.children.map(child=>{
		return renderInput(child,thisObject,h,input);
	});

	processPlaceholders(children,input.entry,h,data.props.naturaPath);

	//generate vdome
	const ret = h(input.comp,data,children);
	
	//add ref to component context
	if(data.ref && false){//disabled
		const ref = calcRef(data.ref,thisObject);
		Object.defineProperty(
			thisObject,
			'component|' + data.ref,
			{
				configurable:true,
				get(){
					return this.$root.$refs[ref];
				}
			}
		)
	}
	
	return ret;
}

function calcObject(entries,thisObject,isEvents=false){
	const ret = {};
	entries.forEach(entry=>{
		//ignore meta properties
		if(['$type','$id'].includes(entry.key)){
			return;
		}
		
		const val = (entry.fn===undefined)? entry.value : calcValue(entry.fn,thisObject);
		if(typeof val !== 'function' && isEvents){
			//if isEvents then all values need to be functions
			return;
		}
		if(entry.key !== undefined){
			ret[entry.key] = val;
		}else if(val && val.key !== undefined){
			//assuming key is not specified and the calculated value returns key,value pair
			ret[val.key] = val.value;
		}
	});

	return ret;
}

function calcValue(fn,thisObject){
	if(Array.isArray(fn)){
		return fn.map(item=>calcValue(item,thisObject))
	}
	if(typeof fn !== 'function'){
		return fn;
	}
	if(fn.isNaturaFactory){
		//entry.fn is a factory function - use it to calculate property
		return fn.call(thisObject,new Context(thisObject));
	}else{
	//entry.fn is a callback function
		return fn.bind(thisObject);
	}
}

/**
 * Given the data generated by getData function, calculate the data value at the time of render.Each data property (props,stle) contains an array of entries
 * @param {*} data 
 * @param {*} thisObject 
 * @returns {Object}
 */
function calcData(data,thisObject,parentData,entry,spec){
	const ret = {
		props: calcObject(data.props,thisObject),
		style: calcObject(data.style,thisObject),
		attrs: calcObject(data.attrs,thisObject),
		on: calcObject(data.on,thisObject,true),
		class:Object.values(calcObject(data.classes,thisObject)),
		ref:calcRef(data.ref,thisObject)
	}

	if(data.slot){
		ret.slot = data.slot;
	}

	//process state props
	//processStateProps(ret,entry,thisObject,spec)

	//in devMode - set dev default
	if(isDevMode() && getLibOption(entry,'devDefault')){
		ret.props = Object.assign({},getLibOption(entry,'devDefault'),ret.props);
	}

	//in devMode - set dev style
	if(isDevMode() && getLibOption(entry,'devStyle')){
		ret.style = Object.assign({},getLibOption(entry,'devStyle'),ret.style);
	}

	//calc npath
	const thisPath = ret.props.naturaPath;
	const parentPath = parentData? parentData.props.naturaPath : null;
	if(parentData && !thisPath){	
		ret.props.naturaPath = parentPath;
	}

	//calculate refInFor. If the parent data is refInFor then this data is also refInFor
	if(ret.refInFor || (parentData && parentData.refInFor)){
		ret.refInFor = true;
	}

	ret.key = data.key;

	//pass context
	ret.props.naturaContext = thisObject;

	//set data-npath
	if(thisPath){
		ret.attrs['data-npath'] = thisPath;
	}
	
	return ret;
}

/**
 * 
 * @param {*} spec 
 * @param {*} elementOrId 
 * @param {*} parentData 
 * @param {*} index 
 */
function getRenderInputFromScript(spec,npath){
	if(!spec){
		return undefined;
	}
	const entry = getLibEntry(spec)
	const comp = entry.value;
	const data = getData(spec,npath);

	//check if there is a condition for display
	const condition = spec && spec.display && spec.display.displayCondition? 
		fn(spec.display.displayCondition,true) :
		undefined;
	
		//check for npath
	if(npath){
		data.props.push({
			key:'naturaPath',
			value:npath
		})
	}
	
	const children = (spec.children||[]).map((child,index)=>
		getRenderInputFromScript(child,(npath||'')+'/children/'+index)
	);
	
	processSlots(data,entry,children,npath)
	return {comp,data,children,condition,entry,spec};
}

/**
 * Given a component spec, return a data object later used to generate the data for createElement function. The spec is the script object describing the component instance
 * @param {*} spec 
 */
function getData(spec,npath){
	const ref = spec.ref;
	
	const props = Object.entries(spec.props||{}).map(
		entry=>dataEntry(entry,(npath||'')+'/props'));
	const display = Object.entries(spec.display||{})
		.filter(([key])=>key!=='ref')//ignore ref property
		.map(entry=>dataEntry(entry,(npath||'')+'/display'));
	const style = (spec.style||[]).map(entry=>styleEntry(entry));
	const attrs = Object.entries(spec.attrs||{}).map(dataEntry);
	const on = Object.entries(spec.on||{}).map(entry=>dataEntry(entry,null,true));
	const classes = (spec.classes||[]).map((item,index)=>dataEntry([index,item]));
	if(spec.$path){
		props.push({key:'naturaPath',value:spec.$path});
	}
	if(ref){
		props.push({key:'nref',value:ref});
		attrs.push({key:'data-nref',value:ref});
	}
	attrs.push({key:'data-ntype',value:spec.$type||'component'});
	
	return {props:props.concat(display),style,ref,attrs,on,classes}
}

/**
 * A data entry is an object with key,value,fn that is used to generate in render time an object. If fn === value then the value is `value`. Otherwise, assume fn is a function calculating value
 */
function dataEntry([key,value],npath,isCallback=false){
	return {
		key,
		value,
		fn:fn(value,(npath||'')+'/' + key,isCallback)
	}
}

function styleEntry(entry,npath){
	if(entry.$type){
		//this is a calculated value
		return {fn:__natura.fn(entry)}
	}
	if(entry.key !== undefined){
		//this was generated using value tag in natura properties
		return {
			key:entry.key,
			fn:entry.value?__natura.fn(entry.value) : undefined
		}
	}
	return {};//entry not understood
}

function getLibEntry(spec){
	const type = spec.$type;
	if(type && window.__natura && __natura.lib && __natura.lib[type]){
		return __natura.lib[type];
	}else{
		return {};
	}
}

function calcRef(name,thisObject){
	if(typeof name !== 'string'){
		return undefined;
	}
	if(thisObject.$contextID){
		return `${name}|${thisObject.$contextID}`;
	}else{
		return name;
	}
}

function processSlots(data,entry,children,npath){
	if(!entry || !entry.options || !entry.options.slots){
		return;
	}
	const slots = entry.options.slots;
	data.props = data.props.filter(({key,value})=>{
		if(!slots[key]){
			//this prop is not a slot
			return true;
		}
		const element = getRenderInputFromScript(value,npath? (npath+'/props/'+key):null);
		if(element){
			const slotEntry = slots[key];
			element.data.slot = slotEntry.name || 'default';
			children.push(element);
		}
	});
}

function fn(spec,npath,isCallback){
	const ret = __natura.fn(spec,isCallback?['event']:undefined);
	if(ret && ret.componentWrapper){
		return fnComponent(ret.def,npath);
	}else{
		return ret;
	}
}

function getLibOption(entry,name){
	if(entry && entry.options && entry.options[name]){
		return entry.options[name];
	}
}

function processStateProps(data,entry,thisObject,spec){
	if(entry && entry.options && entry.options.state){
		const access = `${spec.$id}-value`;
			
		//set context value if doesn't exist yet
		if(!Object.getOwnPropertyDescriptor(thisObject,access)){
			Vue.set(thisObject,access,null);
		}
		data.model = {
			value:thisObject[access],
			expression:access,
			callback(value){
				thisObject[access] = value;
			}
		}
	}
}

function processPlaceholders(children,entry,h,path=''){
	//this function assumes a vue component named plaeholder is registered
	if(isDevMode() && getLibOption(entry,'placeholders')){
		getLibOption(entry,'placeholders').forEach(ph=>{
			children.push(h(
				'placeholder',
				{
					props:{
						tooltip:ph.tooltip,
						size:ph.size,
						naturaPath:path + '/children/-1'
					},
					class:ph.class
				}
			))
		})
	}
}

function deepCopy(src){
	//dumb deep copy
	if(typeof src !== 'object'){
		//no need to deep copy - this is not an object
		return src;
	}
	return JSON.parse(JSON.stringify(src));
}

class Context{
	constructor(data){
		this.data = data;
	}
	get(key){
		return this.data[key];
	}
	set(key,value){
		this.data[key] = value;
	}
	child(data){
		const newData = Object.create(this.data);
		Object.assign(newData,data);
		return new Context(newData)
	}
}