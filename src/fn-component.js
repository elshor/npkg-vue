// @ts-nocheck
/*
 *   Copyright (c) 2021 DSAS Holdings LTD.
 *   All rights reserved.
 */
import {getRenderInputFromScript} from './prepare-render-function'
import { isDevMode } from "./utils";
import {h, isVNode} from 'vue'

function addEntries(target,source){
	source = source || {};
	Object.entries(source).forEach(([key,value])=>target.push({key,value}));
}

export function fnComponent(spec,npath){
	if(!spec){
		return undefined;
	}
	const input = getRenderInputFromScript(spec,npath);
	return function(_,thisObject=null,overrideProps={},overrideData={}){
		input.data.key = overrideData.key || input.data.key;
		input.data.slot = overrideData.slot || input.data.slot;
		input.data.ref = overrideData.ref || input.data.ref;
		input.data.refinFor = overrideData.refInFor || input.data.refInFor;
		addEntries(input.data.props,overrideProps);
		addEntries(input.data.props,overrideData.props);
		addEntries(input.data.on,overrideData.on);
		addEntries(input.data.attrs,overrideData.attrs);
		return renderInput(input,thisObject||this,h);
	}
}

/**
 * Given an input object of comp, data (props, style etc.) and children, generate a vnode
 * @param {Object} input 
 * @param {*} thisObject 
 * @param {Function} h  render function
 * @returns VNode
 */
function renderInput(input,thisObject,h,parentInput){
	if(!input){
		return undefined;
	}

	//if this is a vnode then just return it
	if(isVNode(input)){
		return input;
	}

	//check if display condition exists and true
	if(input.condition){
		const b = input.condition.call(thisObject);
		if(!b){
			return undefined;
		}
	}

	//calculate data
	const data = calcData(
		input.data,
		thisObject,
		parentInput? parentInput.data : null,
		input.entry,
		input.spec
	);

	//register spec id
	data._sid = input.spec.$id;

	//render children
	const children = renderChildren(input,thisObject,h,data);
	//generate vdome
	const ret = h(input.comp,data,children);
	
	//add ref to component context
	if(data.ref && false){//disabled
		const ref = calcRef(data.ref,thisObject);
		Object.defineProperty(
			thisObject,
			'component|' + data.ref,
			{
				configurable:true,
				get(){
					return this.$root.$refs[ref];
				}
			}
		)
	}
	
	return ret;
}

function renderChildren(input,thisObject,h,data){
	console.log('renderChildren',input.children.length,input.children);
	const slots = {};
	input.children.forEach(child=>{
		const slot = child.data.slot || 'default';
		if(!slots[slot]){
			slots[slot] = [];
		}
		slots[slot].push(child);
	});

	processPlaceholders(slots,input.entry,h,data.naturaPath,input.usedSlots);

	return Object.fromEntries(
		Object.entries(slots).map(([key,value])=>{
			return [
				key,
				()=>value.map(input=>renderInput(input,thisObject,h,input))
			]
		})
	)
}

function calcObject(entries,thisObject,isEvents=false){
	const ret = {};
	entries.forEach(entry=>{
		//ignore meta properties
		if(['$type','$id'].includes(entry.key)){
			return;
		}
		
		const val = (entry.fn===undefined)? entry.value : calcValue(entry.fn,thisObject);
		if(typeof val !== 'function' && isEvents){
			//if isEvents then all values need to be functions
			return;
		}
		if(entry.key !== undefined){
			ret[entry.key] = val;
		}else if(val && val.key !== undefined){
			//assuming key is not specified and the calculated value returns key,value pair
			ret[val.key] = val.value;
		}
	});

	return ret;
}

function calcValue(fn,thisObject){
	if(Array.isArray(fn)){
		return fn.map(item=>calcValue(item,thisObject))
	}
	if(typeof fn !== 'function'){
		return fn;
	}
	if(fn.isNaturaFactory){
		//entry.fn is a factory function - use it to calculate property
		return fn.call(thisObject,new Context(thisObject));
	}else{
	//entry.fn is a callback function
		return fn.bind(thisObject);
	}
}

/**
 * Given the data generated by getData function, calculate the data value at the time of render.Each data property (props,stle) contains an array of entries
 * @param {*} data 
 * @param {*} thisObject 
 * @returns {Object}
 */
function calcData(data,thisObject,parentData,entry,spec){
	const ret = calcObject(data.props,thisObject);
	const styleObject = calcObject(data.style,thisObject);
	if(Object.keys(styleObject).length > 0){
		ret.style = styleObject;
	}
	ret.class = Object.values(calcObject(data.classes,thisObject));
	Object.entries(calcObject(data.attrs,thisObject)).forEach(([key,value])=>{
		if(value !== undefined){
			ret[key] = value;
		}
	})
	Object.assign(ret,calcObject(data.on,thisObject,true));
	ret.ref = calcRef(data.ref,thisObject);

	if(data.slot){
		ret.slot = data.slot;
	}

	//in devMode - set dev default
	if(isDevMode() && getLibOption(entry,'devDefault')){
		ret = Object.assign({},getLibOption(entry,'devDefault'),ret);
	}

	//in devMode - set dev style
	if(isDevMode() && getLibOption(entry,'devStyle')){
		ret.style = Object.assign({},getLibOption(entry,'devStyle'),ret.style||{});
	}

	//calc npath
	const thisPath = ret.naturaPath;
	const parentPath = parentData? parentData.naturaPath : null;
	if(parentData && !thisPath){	
		ret.naturaPath = parentPath;
	}

	//calculate refInFor. If the parent data is refInFor then this data is also refInFor
	if(ret.refInFor || (parentData && parentData.refInFor)){
		ret.refInFor = true;
	}

	ret.key = data.key;

	//pass context
	ret.naturaContext = thisObject;

	//set data-npath
	if(thisPath){
		ret['data-npath'] = thisPath;
	}
	
	return ret;
}




function calcRef(name,thisObject){
	if(typeof name !== 'string'){
		return undefined;
	}
	if(thisObject.$contextID){
		return `${name}|${thisObject.$contextID}`;
	}else{
		return name;
	}
}


function getLibOption(entry,name){
	if(entry && entry.options && entry.options[name]){
		return entry.options[name];
	}
}

function processPlaceholders(slots,entry,h,path='',usedSlots){
	//this function assumes a vue component named plaeholder is registered
	if(isDevMode() && getLibOption(entry,'placeholders')){
		getLibOption(entry,'placeholders').forEach(ph=>{
			if(ph.slot && (usedSlots||[]).includes(ph.slot)){
				//this slot is not missing - don't add it
				return;
			}
			const relativePath = (ph.prop||ph.slot)? '/props/' + (ph.prop||ph.slot) : '/children/-1';
			if(!slots[ph.slot||'default']){
				slots[ph.slot||'default'] = [];
			}
			slots[ph.slot||'default'].push(h(
				'placeholder',
				{
					props:{
						tooltip:ph.tooltip,
						size:ph.size,
						naturaPath:path + relativePath
					},
					class:ph.class,
					slot:ph.slot
				}
			))
		})
	}
}

class Context{
	constructor(data){
		this.data = data;
	}
	get(key){
		return this.data[key];
	}
	set(key,value){
		this.data[key] = value;
	}
	child(data){
		const newData = Object.create(this.data);
		Object.assign(newData,data);
		return new Context(newData)
	}
}

